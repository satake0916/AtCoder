
/*
int right = 0;     
for (int left = 0; left < n; ++left) {
    while (right < n && (right を 1 個進めたときに条件を満たす)) {
        実際に right を 1 進める
        //ex: sum += a[right]
        ++right;
    }

    break した状態で right は条件を満たす最大なので、何かする
    // ex: res += (right - left);

    left をインクリメントする準備
    // ex: if (right == left) ++right;
    // ex: else sum -= a[left];
}




1-3. しゃくとり法が使える条件

しゃくとり法は

    「条件」を満たす区間 (連続する部分列) のうち、最小の長さを求める
    「条件」を満たす区間 (連続する部分列) のうち、最大の長さを求める
    「条件」を満たす区間 (連続する部分列) を数え上げる

といったことを効率良く実現できる手法ですが、「条件」というのが何でもいいわけではないです。「条件を満たす区間」が以下のいずれかの構造になっている場合には、しゃくとり法を適用することができます:

    区間 [left, right) が「条件」を満たすなら、それに含まれる区間も「条件」を満たす
    区間 [left, right) が「条件」を満たすなら、それを含む区間も「条件」を満たす

例えば、上の表の問題 1 の条件「総和が xx 以下」については 1 個目の構造になっています。逆に問題 2 の条件「総和が xx 以上」については 2 個目の構造になっています。

1 個目の構造になっているとき、一般に

    区間の左端 left に対する、条件を満たす右端の最大値 f(left) は広義単調増加関数

という風になるのでしゃくとり法が使えます。反対に 2 個目の構造になっている場合は

    区間の左端 left に対する、条件を満たす右端の最小値 f(left) は広義単調増加関数

という風になります。
*/